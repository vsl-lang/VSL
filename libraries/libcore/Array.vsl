// omy y so long `enumeration` and not `enum` ;_;
///should this be inside Array
// imo we don't need `Enumeration<>` because always going to be enum
// yean but inheritance. i mean internally probably won't inherit because enum
// polymorphism shouldn't really be a thing because independent so would 
// implicitly subclass Object but would implicitly conform to static polymorphic
// standards in VSL.
// imo this is better though because implies implicit cast
// v-- here

// Wait what is Iterator<Boolean> mean
// oh like Iterable object?
// uhh idk supposed to be like generator
// how about we have like Sequence type and `T[]` is actually sequence type.
// isn't T[] array
// but signature wrong it needs to be able to recieve state -> return next comparison?
// or recieve array but imo should be same for both in-place and not
enum SortingMethod<T> { // is this correct associated array syntax
    // // ok wrong signature it needs to recieve state and decide on next
    // Merge = MergeSort = (T, T) -> //do we capitalize s
    // how about:
    
    // imo look beter with `case`
    case merge, quicksort
    
    // ok idea but imo should be DRY so we can just use same code, only changing the assignment in the 
    // Array class method impl (sort vs sorted)
    // but wouldn't they use different impl. because u can have major optimize
    // if doing inplace or copy
    // no, only default sort method would be different
    // but slow ;_; shouldn't be slow we can make them inline or whatever but brb 3 minutes late already
    public fn sort<T>(sequence: T[]) -> T[] {
        switch self {
            case .merge: 
                if array.length > 2 {
                    return self.merge(
                        self.sort(array.tail(#middle)),
                        self.sort(array.head(#middle))
                    )
                } else {
                    return [array.min, array.max]
                }
            case .quicksort:
                // ...
        }
    }
}

public class Array<T> {
    // do we use hash for enum member?
    // we use `EnumName.member`
    // example:
    // [1,2,3].sort()
    // [1,2,3] sort using: .quicksort /// :D i use comand chain
    public fn sort(using method: SortingMethod = .merge) -> Array<T> {
        // Quetion: is `self` reserve word?
        // self should be reserve so you don't do like `let self` and
        // cause uber bork beacuse function would eb like:
        // define i8* sort(i8* %self, i32 %method) {
        //     %2 = alloca i8*, i64 getelementptr inbounds (%0, i64 1)
        //     ret i8* %2
        // }
        // so because self is there imo make sense to make a parm
    }
    
    public var sorted: T[] {
        
    }
}